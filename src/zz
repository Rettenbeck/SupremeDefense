// SFML 2D PostFX + Bloom + 2D Light (single-file demo)
// - Scene -> BrightPass -> Gaussian Blur (ping-pong) -> Combine with Lightmap
// - Works with SFML 2.6+ (GLSL 1.20 style). Should also work with SFML 2.5.
//
// Build (Linux/macOS example):
//   g++ main.cpp -std=c++17 -lsfml-graphics -lsfml-window -lsfml-system -O2 -o demo
// Windows (MinGW): link sfml-graphics sfml-window sfml-system accordingly.
//
// Controls:
//   Mouse       : move light
//   Mouse Wheel : change light radius
//   B           : toggle bloom
//   L           : toggle dynamic light
//   T           : show bright-pass (debug)
//   +/-         : adjust bloom strength
//   [/]         : adjust bright threshold
//   A/Z         : adjust ambient
//
// #include <SFML/Graphics.hpp>
// #include <cmath>
// #include <iostream>

// ---------------- Shader Sources (GLSL 130 for SFML 3 core) ----------------
// In SFML 3 / core profile we must provide our own vertex shader and avoid legacy
// built-ins like gl_FragColor or gl_TexCoord. We use attribute names that SFML
// binds: a_position, a_color, a_texCoords; and uniforms u_transform/u_projection.


static const char* FULLSCREEN_VERT = R"GLSL(
#version 130
in vec2 a_position;
in vec4 a_color;
in vec2 a_texCoords;

out vec2 vScreenUV;   // 0..1 über den Ziel-RenderTexture/Screen
out vec4 vColor;

uniform mat3 u_transform;
uniform mat3 u_projection;
uniform vec2 uInvScreen; // (1/width, 1/height) des aktuellen RenderTargets

void main(){
    vec3 world = u_transform * vec3(a_position, 1.0);
    vec3 proj  = u_projection * world;
    gl_Position = vec4(proj.xy, 0.0, 1.0);

    // world.xy ist in Pixeln – normieren auf 0..1:
    vScreenUV = world.xy * uInvScreen;
    vColor = a_color;
}
)GLSL";

static const char* THRESHOLD_FRAG = R"GLSL(
#version 130
uniform sampler2D uScene;
uniform float uThreshold;
in vec2 vScreenUV;
out vec4 fragColor;
void main(){
    vec3 c = texture(uScene, vScreenUV).rgb;
    float luma = dot(c, vec3(0.2126,0.7152,0.0722));
    vec3 bright = (luma > uThreshold) ? c : vec3(0.0);
    fragColor = vec4(bright, 1.0);
}
)GLSL";

static const char* GAUSS_BLUR_FRAG = R"GLSL(
#version 130
uniform sampler2D uTex;
uniform vec2 uTexel;
uniform vec2 uDirection;
in vec2 vScreenUV;
out vec4 fragColor;
void main(){
    float w0=0.227027, w1=0.1945946, w2=0.1216216, w3=0.054054, w4=0.016216;
    vec3 acc = texture(uTex, vScreenUV).rgb * w0;
    vec2 off;
    off=uDirection*uTexel*1.0; acc+=texture(uTex, vScreenUV+off).rgb*w1; acc+=texture(uTex, vScreenUV-off).rgb*w1;
    off=uDirection*uTexel*2.0; acc+=texture(uTex, vScreenUV+off).rgb*w2; acc+=texture(uTex, vScreenUV-off).rgb*w2;
    off=uDirection*uTexel*3.0; acc+=texture(uTex, vScreenUV+off).rgb*w3; acc+=texture(uTex, vScreenUV-off).rgb*w3;
    off=uDirection*uTexel*4.0; acc+=texture(uTex, vScreenUV+off).rgb*w4; acc+=texture(uTex, vScreenUV-off).rgb*w4;
    fragColor = vec4(acc,1.0);
}

)GLSL";

static const char* LIGHT_FRAG = R"GLSL(
#version 130
uniform vec2 uLightPos;   // normalized [0,1]
uniform float uRadius;
uniform vec3 uColor;
in vec2 vScreenUV;
out vec4 fragColor;
void main(){
    float d = distance(vScreenUV, uLightPos);
    float falloff = smoothstep(0.0, 1.0, clamp(1.0 - d/uRadius, 0.0, 1.0));
    fragColor = vec4(uColor * falloff, 1.0);
}

)GLSL";

static const char* COMBINE_FRAG = R"GLSL(
#version 130
uniform sampler2D uScene, uBloom, uLight;
uniform float uBloomStrength, uAmbient;
in vec2 vScreenUV;
out vec4 fragColor;
vec3 acesTonemap(vec3 x){ const float a=2.51,b=0.03,c=2.43,d=0.59,e=0.14; return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0,1.0); }
void main(){
    vec3 scene = texture(uScene,  vScreenUV).rgb;
    vec3 bloom = texture(uBloom,  vScreenUV).rgb * uBloomStrength;
    vec3 light = texture(uLight,  vScreenUV).rgb;
    vec3 color = acesTonemap(scene * clamp(uAmbient + light, 0.0, 1.5) + bloom);
    fragColor = vec4(color, 1.0);
}

)GLSL";


int main(){
    const unsigned W = 1280, H = 720;
    auto inv = sf::Glsl::Vec2(1.f/W, 1.f/H);

    sf::RenderWindow window(sf::VideoMode({W, H}), "2D PostFX + Bloom + Light (SFML)");
    window.setVerticalSyncEnabled(true);

    // Render targets
    sf::RenderTexture rtScene({W, H});
    sf::RenderTexture rtBright({W, H});
    sf::RenderTexture rtPing({W, H});
    sf::RenderTexture rtPong({W, H});
    sf::RenderTexture rtLight({W, H});

    // Shaders
    sf::Shader shThreshold, shBlur, shLight, shCombine;
    if (!shThreshold.loadFromMemory(FULLSCREEN_VERT, THRESHOLD_FRAG) ||
        !shBlur.loadFromMemory(FULLSCREEN_VERT, GAUSS_BLUR_FRAG) ||
        !shLight.loadFromMemory(FULLSCREEN_VERT, LIGHT_FRAG) ||
        !shCombine.loadFromMemory(FULLSCREEN_VERT, COMBINE_FRAG)){
        std::cerr << "Failed to load shaders" << std::endl; return 1;
    }

    // Demo scene (procedural textures) --------------------------------------
    sf::Texture texBlob, texChecker;
    {
        sf::Image img({256,256},sf::Color::Transparent);
        for (unsigned y=0;y<256;y++) for(unsigned x=0;x<256;x++){
            float u=float(x)/255.f, v=float(y)/255.f;
            float r2 = (u-0.5f)*(u-0.5f)+(v-0.5f)*(v-0.5f);
            float a = std::exp(-8.0f*r2);
            std::uint8_t A = (std::uint8_t)std::round(255*a);
            img.setPixel({x,y}, sf::Color(255, 160, 40, A)); // soft orange blob
        }
        auto texR = texBlob.loadFromImage(img); texBlob.setSmooth(true);
    }
    {
        sf::Image img({128,128},sf::Color::White);
        for(unsigned y=0;y<128;y++) for(unsigned x=0;x<128;x++){
            bool checker = ((x/16 + y/16) % 2)==0;
            img.setPixel({x, y}, {checker?sf::Color(40,180,255):sf::Color(5,60,90)});
        }
        auto texR = texChecker.loadFromImage(img); texChecker.setSmooth(true);
    }
    sf::Sprite sprBlob(texBlob);   sprBlob.setPosition({320, 320});
    sf::Sprite sprCheck(texChecker);sprCheck.setPosition({740, 420}); sprCheck.setScale({2.f,2.f});

    // Fullscreen quad (we just draw textured rectangle)
    sf::RectangleShape fsQuad(sf::Vector2f((float)W,(float)H));
    fsQuad.setPosition({0,0});

    // Params & toggles -------------------------------------------------------
    bool enableBloom = true;
    bool enableLight = true;
    bool viewThreshold = false;

    float bloomThreshold = 0.85f; // luma threshold
    float bloomStrength  = 0.85f; // final blend strength
    float ambient        = 0.18f; // ambient factor

    float lightRadiusPx = 260.0f;
    sf::Vector2f lightPos((float)W*0.5f, (float)H*0.5f);

    while(window.isOpen()){
        while (const std::optional<sf::Event> ev = window.pollEvent()) {
            if (ev.value().is<sf::Event::Closed>()) window.close();
            if (const auto* keyEvent = ev.value().getIf<sf::Event::KeyPressed>()){
                if (keyEvent->code == sf::Keyboard::Key::B) enableBloom = !enableBloom;
                if (keyEvent->code == sf::Keyboard::Key::L) enableLight = !enableLight;
                if (keyEvent->code == sf::Keyboard::Key::T) viewThreshold = !viewThreshold;
                if (keyEvent->code == sf::Keyboard::Key::Add || keyEvent->code == sf::Keyboard::Key::Equal) bloomStrength = std::min(2.f, bloomStrength + 0.05f);
                if (keyEvent->code == sf::Keyboard::Key::Hyphen || keyEvent->code == sf::Keyboard::Key::Subtract) bloomStrength = std::max(0.f, bloomStrength - 0.05f);
                if (keyEvent->code == sf::Keyboard::Key::LBracket) bloomThreshold = std::max(0.f, bloomThreshold - 0.02f);
                if (keyEvent->code == sf::Keyboard::Key::RBracket) bloomThreshold = std::min(1.f, bloomThreshold + 0.02f);
                if (keyEvent->code == sf::Keyboard::Key::A) ambient = std::min(1.f, ambient + 0.02f);
                if (keyEvent->code == sf::Keyboard::Key::Z) ambient = std::max(0.f, ambient - 0.02f);
            }
            if (const auto* mouseWheelEvent = ev->getIf<sf::Event::MouseWheelScrolled>()) {
                lightRadiusPx = std::max(40.f, lightRadiusPx + mouseWheelEvent->delta*20.f);
            }
        }

        // Light follows mouse
        sf::Vector2i m = sf::Mouse::getPosition(window);
        lightPos = sf::Vector2f((float)m.x,(float)m.y);

        // ---------- 1) Render Scene ----------
        rtScene.clear(sf::Color(18,18,24));
        // background gradient via two rectangles
        sf::RectangleShape bgTop(sf::Vector2f((float)W,(float)H*0.5f));
        bgTop.setFillColor(sf::Color(28,28,40)); bgTop.setPosition({0,0}); rtScene.draw(bgTop);
        sf::RectangleShape bgBot(sf::Vector2f((float)W,(float)H*0.5f));
        bgBot.setFillColor(sf::Color(15,15,22)); bgBot.setPosition({0,(float)H*0.5f}); rtScene.draw(bgBot);
        // demo sprites
        rtScene.draw(sprBlob);
        rtScene.draw(sprCheck);
        rtScene.display();

        // ---------- 2) Bright Pass ----------
        rtBright.clear(sf::Color::Black);
        shThreshold.setUniform("uScene", rtScene.getTexture());
        shThreshold.setUniform("uThreshold", enableBloom ? bloomThreshold : 2.0f); // disable by pushing threshold high
        fsQuad.setTexture(&rtScene.getTexture());
        shThreshold.setUniform("uInvScreen", inv);
        rtBright.draw(fsQuad, &shThreshold);
        rtBright.display();

        if (viewThreshold){
            window.clear();
            sf::Sprite s(rtBright.getTexture());
            window.draw(s);
            window.display();
            continue; // skip the rest to view the bright areas
        }

        // ---------- 3) Gaussian Blur (ping-pong) ----------
        // Horizontal pass
        rtPing.clear(sf::Color::Black);
        shBlur.setUniform("uTex", rtBright.getTexture());
        shBlur.setUniform("uTexel", sf::Glsl::Vec2(1.0f/W, 1.0f/H));
        shBlur.setUniform("uDirection", sf::Glsl::Vec2(1.0f, 0.0f));
        fsQuad.setTexture(&rtBright.getTexture());
        rtPing.draw(fsQuad, &shBlur);
        rtPing.display();
        // Vertical pass
        rtPong.clear(sf::Color::Black);
        shBlur.setUniform("uTex", rtPing.getTexture());
        shBlur.setUniform("uDirection", sf::Glsl::Vec2(0.0f, 1.0f));
        fsQuad.setTexture(&rtPing.getTexture());
        shBlur.setUniform("uInvScreen", inv);
        rtPong.draw(fsQuad, &shBlur);
        rtPong.display();

        // ---------- 4) Light buffer ----------
        rtLight.clear(sf::Color::Black);
        if (enableLight){
            shLight.setUniform("uLightPos", sf::Glsl::Vec2(lightPos.x/W, lightPos.y/H));
            float normRadius = lightRadiusPx / (float)std::min(W,H);
            shLight.setUniform("uRadius", normRadius);
            shLight.setUniform("uColor", sf::Glsl::Vec3(1.0f, 0.95f, 0.85f)); // warm light
            // fsQuad.setTexture(nullptr); // pure shader
            shLight.setUniform("uInvScreen", inv);
            rtLight.draw(fsQuad, &shLight);
        }
        rtLight.display();

        // ---------- 5) Combine ----------
        window.clear();
        // ImGui::ShowMetricsWindow();
        shCombine.setUniform("uScene", rtScene.getTexture());
        shCombine.setUniform("uBloom", rtPong.getTexture());
        shCombine.setUniform("uLight", rtLight.getTexture());
        shCombine.setUniform("uBloomStrength", enableBloom ? bloomStrength : 0.0f);
        shCombine.setUniform("uAmbient", ambient);
        fsQuad.setTexture(&rtScene.getTexture()); // any bound texture works; shader samples explicitly
        shCombine.setUniform("uInvScreen", inv);
        window.draw(fsQuad, &shCombine);
        window.display();
    }

    return 0;
}
